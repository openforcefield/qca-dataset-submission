#!/usr/bin/env python

import os
import json
import tarfile

import qcportal as ptl

torsion_data_gz = "selected-torsions.tar.jz"
torsion_data = "selected-torsions.json"
dataset_name = "Fragmenter paper"
local_run = False


def read_selected_torsions(input_json):
    """ Read data generated by select_torsions.py
    Returns
    -------
    selected_torsions: dict
        Dictionary for selected torsions, has this structure:
        {
            canonical_torsion_index1: {
                'initial_molecules': [ Molecule1a, Molecule1b, .. ],
                'atom_indices': [ (0,1,2,3) ],
                'attributes': {'canonical_explicit_hydrogen_smiles': .., 'canonical_isomeric_smiles': .., ..}
            },
            ..
        }
    """
    with open(input_json) as infile:
        selected_torsions = json.load(infile)
    return selected_torsions


print("Reading selected_torsions...")

if not os.path.exists(torsion_data):
    with tarfile.open(torsion_data_gz) as f:
        f.extractfile(torsion_data)
selected_torsions = read_selected_torsions(torsion_data)

print(f"Found {len(selected_torsions)} torsions")

print("Initializing dataset...")
if local_run:
    client = ptl.FractalClient("localhost:7777", verify=False)
else:
    client = ptl.FractalClient.from_file()

# create a new dataset with specified name

#ds = ptl.collections.TorsionDriveDataset(dataset_name, client=client)
ds = client.get_collection("torsiondrivedataset", dataset_name)

# create specification for this dataset
opt_spec = {
    "program": "geometric",
    "keywords": {
        "coordsys": "tric",
        "enforce": 0.1,
        "reset": True,
        "qccnv": True,
        "epsilon": 0.0,
    }
}

qc_spec = {
    'driver': "gradient",
    'method': 'b3lyp-d3(bj)',
    'program': 'psi4',
    'basis': 'dzvp',
    'keywords': 2
}  # Keywords 2 id map compute wiberg bond orders, dipoles, and quadrupoles.

ds.add_specification("default",
                     opt_spec,
                     qc_spec,
                     description="Standard OpenFF torsiondrive specification.",
                     overwrite=True)

# add molecules
print(f"Adding {len(selected_torsions)} torsions")
i = 0
for canonical_torsion_index, torsion_data in selected_torsions.items():
    print(i, canonical_torsion_index, len(torsion_data['input_molecules']))
    if isinstance(torsion_data['input_molecules'], dict):
        torsion_data['input_molecules'] = [torsion_data['input_molecules']]
    ds.add_entry(canonical_torsion_index,
                 torsion_data['input_molecules'],
                 torsion_data['dihedral'],
                 torsion_data['grid'],
                 energy_upper_limit=0.1,
                 attributes=torsion_data['cmiles_identifiers'])
    i += 1
print("Submitting tasks...")
comp = ds.compute("default", tag="openff")
print(comp)

print("Complete!")